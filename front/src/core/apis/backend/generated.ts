//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from "axios";
import axios, { AxiosError } from "axios";

export class DeploysFtpClient {
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
	private instance: AxiosInstance;
	private baseUrl: string;

	constructor(baseUrl?: string, instance?: AxiosInstance) {
		this.instance = instance ? instance : axios.create();

		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
	}

	/**
	 * Get all FTP deployment configurationsÂ²
	 * @return Success
	 */
	getFtpDeployment(cancelToken?: CancelToken | undefined): Promise<FtpDeployData[]> {
		let url_ = this.baseUrl + "/api/deploys/ftp";
		url_ = url_.replace(/[?&]$/, "");

		let options_: AxiosRequestConfig = {
			method: "GET",
			url: url_,
			headers: {
				Accept: "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processGetFtpDeployment(_response);
			});
	}

	/**
	 * Create a new FTP deployment configuration
	 * @return No Content
	 */
	createFtpDeploy(body: FtpDeployBase, cancelToken?: CancelToken | undefined): Promise<void> {
		let url_ = this.baseUrl + "/api/deploys/ftp";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(body);

		let options_: AxiosRequestConfig = {
			data: content_,
			method: "POST",
			url: url_,
			headers: {
				"Content-Type": "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processCreateFtpDeploy(_response);
			});
	}

	/**
	 * Delete a FTP deployment configuration
	 * @return No Content
	 */
	deleteFtpDeploy(idDeploy: string, cancelToken?: CancelToken | undefined): Promise<void> {
		let url_ = this.baseUrl + "/api/deploys/ftp/{idDeploy}";
		if (idDeploy === undefined || idDeploy === null) throw new Error("The parameter 'idDeploy' must be defined.");
		url_ = url_.replace("{idDeploy}", encodeURIComponent("" + idDeploy));
		url_ = url_.replace(/[?&]$/, "");

		let options_: AxiosRequestConfig = {
			method: "DELETE",
			url: url_,
			headers: {},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processDeleteFtpDeploy(_response);
			});
	}

	/**
	 * Replace a FTP deployment configuration
	 * @param idDeploy Connection's id
	 * @param body new config
	 * @return No Content
	 */
	updateFtpDeploy(idDeploy: string, body: FtpDeployData, cancelToken?: CancelToken | undefined): Promise<void> {
		let url_ = this.baseUrl + "/api/deploys/ftp/{idDeploy}";
		if (idDeploy === undefined || idDeploy === null) throw new Error("The parameter 'idDeploy' must be defined.");
		url_ = url_.replace("{idDeploy}", encodeURIComponent("" + idDeploy));
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(body);

		let options_: AxiosRequestConfig = {
			data: content_,
			method: "PUT",
			url: url_,
			headers: {
				"Content-Type": "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processUpdateFtpDeploy(_response);
			});
	}

	protected processGetFtpDeployment(response: AxiosResponse): Promise<FtpDeployData[]> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 200) {
			const _responseText = response.data;
			let result200: any = null;
			let resultData200 = _responseText;
			result200 = JSON.parse(resultData200);
			return Promise.resolve<FtpDeployData[]>(result200);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<FtpDeployData[]>(null as any);
	}

	protected processCreateFtpDeploy(response: AxiosResponse): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 204) {
			const _responseText = response.data;
			return Promise.resolve<void>(null as any);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<void>(null as any);
	}

	protected processDeleteFtpDeploy(response: AxiosResponse): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 204) {
			const _responseText = response.data;
			return Promise.resolve<void>(null as any);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<void>(null as any);
	}

	protected processUpdateFtpDeploy(response: AxiosResponse): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 204) {
			const _responseText = response.data;
			return Promise.resolve<void>(null as any);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<void>(null as any);
	}
}

export class DeploysLocalClient {
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
	private instance: AxiosInstance;
	private baseUrl: string;

	constructor(baseUrl?: string, instance?: AxiosInstance) {
		this.instance = instance ? instance : axios.create();

		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
	}

	/**
	 * Get all local deployment configurations
	 * @return Success
	 */
	getLocalDeployments(cancelToken?: CancelToken | undefined): Promise<LocalDeployData[]> {
		let url_ = this.baseUrl + "/api/deploys/local";
		url_ = url_.replace(/[?&]$/, "");

		let options_: AxiosRequestConfig = {
			method: "GET",
			url: url_,
			headers: {
				Accept: "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processGetLocalDeployments(_response);
			});
	}

	/**
	 * Create a new local deployment configuration
	 * @return No Content
	 */
	createLocalDeploy(body: LocalDeployBase, cancelToken?: CancelToken | undefined): Promise<void> {
		let url_ = this.baseUrl + "/api/deploys/local";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(body);

		let options_: AxiosRequestConfig = {
			data: content_,
			method: "POST",
			url: url_,
			headers: {
				"Content-Type": "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processCreateLocalDeploy(_response);
			});
	}

	/**
	 * Delete a local deployment configuration
	 * @return No Content
	 */
	deleteLocalDeploy(idDeploy: string, cancelToken?: CancelToken | undefined): Promise<void> {
		let url_ = this.baseUrl + "/api/deploys/local/{idDeploy}";
		if (idDeploy === undefined || idDeploy === null) throw new Error("The parameter 'idDeploy' must be defined.");
		url_ = url_.replace("{idDeploy}", encodeURIComponent("" + idDeploy));
		url_ = url_.replace(/[?&]$/, "");

		let options_: AxiosRequestConfig = {
			method: "DELETE",
			url: url_,
			headers: {},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processDeleteLocalDeploy(_response);
			});
	}

	/**
	 * Replace a local deployment configuration
	 * @param idDeploy Connection's id
	 * @param body new config
	 * @return No Content
	 */
	updateLocalDeploy(idDeploy: string, body: LocalDeployBase, cancelToken?: CancelToken | undefined): Promise<void> {
		let url_ = this.baseUrl + "/api/deploys/local/{idDeploy}";
		if (idDeploy === undefined || idDeploy === null) throw new Error("The parameter 'idDeploy' must be defined.");
		url_ = url_.replace("{idDeploy}", encodeURIComponent("" + idDeploy));
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(body);

		let options_: AxiosRequestConfig = {
			data: content_,
			method: "PUT",
			url: url_,
			headers: {
				"Content-Type": "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processUpdateLocalDeploy(_response);
			});
	}

	protected processGetLocalDeployments(response: AxiosResponse): Promise<LocalDeployData[]> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 200) {
			const _responseText = response.data;
			let result200: any = null;
			let resultData200 = _responseText;
			result200 = JSON.parse(resultData200);
			return Promise.resolve<LocalDeployData[]>(result200);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<LocalDeployData[]>(null as any);
	}

	protected processCreateLocalDeploy(response: AxiosResponse): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 204) {
			const _responseText = response.data;
			return Promise.resolve<void>(null as any);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<void>(null as any);
	}

	protected processDeleteLocalDeploy(response: AxiosResponse): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 204) {
			const _responseText = response.data;
			return Promise.resolve<void>(null as any);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<void>(null as any);
	}

	protected processUpdateLocalDeploy(response: AxiosResponse): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 204) {
			const _responseText = response.data;
			return Promise.resolve<void>(null as any);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<void>(null as any);
	}
}

export class JobsClient {
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
	private instance: AxiosInstance;
	private baseUrl: string;

	constructor(baseUrl?: string, instance?: AxiosInstance) {
		this.instance = instance ? instance : axios.create();

		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
	}

	/**
	 * Get all jobs
	 * @return Success
	 */
	getJobs(cancelToken?: CancelToken | undefined): Promise<JobData[]> {
		let url_ = this.baseUrl + "/api/jobs";
		url_ = url_.replace(/[?&]$/, "");

		let options_: AxiosRequestConfig = {
			method: "GET",
			url: url_,
			headers: {
				Accept: "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processGetJobs(_response);
			});
	}

	/**
	 * Create a new job
	 * @return No Content
	 */
	createJob(body: CreateJobRequest, cancelToken?: CancelToken | undefined): Promise<void> {
		let url_ = this.baseUrl + "/api/jobs";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(body);

		let options_: AxiosRequestConfig = {
			data: content_,
			method: "POST",
			url: url_,
			headers: {
				"Content-Type": "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processCreateJob(_response);
			});
	}

	/**
	 * Update a job
	 * @return No Content
	 */
	updateJob(idJob: string, body: CreateJobRequest, cancelToken?: CancelToken | undefined): Promise<void> {
		let url_ = this.baseUrl + "/api/jobs/{idJob}";
		if (idJob === undefined || idJob === null) throw new Error("The parameter 'idJob' must be defined.");
		url_ = url_.replace("{idJob}", encodeURIComponent("" + idJob));
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(body);

		let options_: AxiosRequestConfig = {
			data: content_,
			method: "PUT",
			url: url_,
			headers: {
				"Content-Type": "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processUpdateJob(_response);
			});
	}

	/**
	 * Delete a job
	 * @return No Content
	 */
	deleteJob(idJob: string, cancelToken?: CancelToken | undefined): Promise<void> {
		let url_ = this.baseUrl + "/api/jobs/{idJob}";
		if (idJob === undefined || idJob === null) throw new Error("The parameter 'idJob' must be defined.");
		url_ = url_.replace("{idJob}", encodeURIComponent("" + idJob));
		url_ = url_.replace(/[?&]$/, "");

		let options_: AxiosRequestConfig = {
			method: "DELETE",
			url: url_,
			headers: {},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processDeleteJob(_response);
			});
	}

	protected processGetJobs(response: AxiosResponse): Promise<JobData[]> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 200) {
			const _responseText = response.data;
			let result200: any = null;
			let resultData200 = _responseText;
			result200 = JSON.parse(resultData200);
			return Promise.resolve<JobData[]>(result200);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<JobData[]>(null as any);
	}

	protected processCreateJob(response: AxiosResponse): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 204) {
			const _responseText = response.data;
			return Promise.resolve<void>(null as any);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<void>(null as any);
	}

	protected processUpdateJob(response: AxiosResponse): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 204) {
			const _responseText = response.data;
			return Promise.resolve<void>(null as any);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<void>(null as any);
	}

	protected processDeleteJob(response: AxiosResponse): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 204) {
			const _responseText = response.data;
			return Promise.resolve<void>(null as any);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<void>(null as any);
	}
}

export class MongoBackupClient {
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
	private instance: AxiosInstance;
	private baseUrl: string;

	constructor(baseUrl?: string, instance?: AxiosInstance) {
		this.instance = instance ? instance : axios.create();

		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
	}

	/**
	 * Get all mongo backup task configurations
	 * @return Success
	 */
	getMongoTasks(cancelToken?: CancelToken | undefined): Promise<MongoBackupTaskData[]> {
		let url_ = this.baseUrl + "/api/tasks/backup/mongo";
		url_ = url_.replace(/[?&]$/, "");

		let options_: AxiosRequestConfig = {
			method: "GET",
			url: url_,
			headers: {
				Accept: "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processGetMongoTasks(_response);
			});
	}

	/**
	 * Create a new mongo backup task configuration
	 * @return No Content
	 */
	createMongoTask(body: MongoBackupTaskBase, cancelToken?: CancelToken | undefined): Promise<void> {
		let url_ = this.baseUrl + "/api/tasks/backup/mongo";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(body);

		let options_: AxiosRequestConfig = {
			data: content_,
			method: "POST",
			url: url_,
			headers: {
				"Content-Type": "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processCreateMongoTask(_response);
			});
	}

	/**
	 * Update a  mongo backup task configuration
	 * @return No Content
	 */
	updateMongoTask(idTask: string, body: MongoBackupTaskBase, cancelToken?: CancelToken | undefined): Promise<void> {
		let url_ = this.baseUrl + "/api/tasks/backup/mongo/{idTask}";
		if (idTask === undefined || idTask === null) throw new Error("The parameter 'idTask' must be defined.");
		url_ = url_.replace("{idTask}", encodeURIComponent("" + idTask));
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(body);

		let options_: AxiosRequestConfig = {
			data: content_,
			method: "PUT",
			url: url_,
			headers: {
				"Content-Type": "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processUpdateMongoTask(_response);
			});
	}

	/**
	 * Delete a mongo backup task configurations
	 * @return No Content
	 */
	deleteMongoTask(idTask: string, cancelToken?: CancelToken | undefined): Promise<void> {
		let url_ = this.baseUrl + "/api/tasks/backup/mongo/{idTask}";
		if (idTask === undefined || idTask === null) throw new Error("The parameter 'idTask' must be defined.");
		url_ = url_.replace("{idTask}", encodeURIComponent("" + idTask));
		url_ = url_.replace(/[?&]$/, "");

		let options_: AxiosRequestConfig = {
			method: "DELETE",
			url: url_,
			headers: {},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processDeleteMongoTask(_response);
			});
	}

	protected processGetMongoTasks(response: AxiosResponse): Promise<MongoBackupTaskData[]> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 200) {
			const _responseText = response.data;
			let result200: any = null;
			let resultData200 = _responseText;
			result200 = JSON.parse(resultData200);
			return Promise.resolve<MongoBackupTaskData[]>(result200);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<MongoBackupTaskData[]>(null as any);
	}

	protected processCreateMongoTask(response: AxiosResponse): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 204) {
			const _responseText = response.data;
			return Promise.resolve<void>(null as any);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<void>(null as any);
	}

	protected processUpdateMongoTask(response: AxiosResponse): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 204) {
			const _responseText = response.data;
			return Promise.resolve<void>(null as any);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<void>(null as any);
	}

	protected processDeleteMongoTask(response: AxiosResponse): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 204) {
			const _responseText = response.data;
			return Promise.resolve<void>(null as any);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<void>(null as any);
	}
}

export class MongoDatabaseClient {
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
	private instance: AxiosInstance;
	private baseUrl: string;

	constructor(baseUrl?: string, instance?: AxiosInstance) {
		this.instance = instance ? instance : axios.create();

		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
	}

	/**
	 * Get informations about databases, collections, sizes for all connections
	 * @return Success
	 */
	getInfos(cancelToken?: CancelToken | undefined): Promise<GetConnectionInformationResponse> {
		let url_ = this.baseUrl + "/api/database/infos";
		url_ = url_.replace(/[?&]$/, "");

		let options_: AxiosRequestConfig = {
			method: "GET",
			url: url_,
			headers: {
				Accept: "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processGetInfos(_response);
			});
	}

	/**
	 * Get all databases connections available
	 * @return Success
	 */
	getConnections(cancelToken?: CancelToken | undefined): Promise<MongoConnectionData[]> {
		let url_ = this.baseUrl + "/api/database/connections";
		url_ = url_.replace(/[?&]$/, "");

		let options_: AxiosRequestConfig = {
			method: "GET",
			url: url_,
			headers: {
				Accept: "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processGetConnections(_response);
			});
	}

	/**
	 * Add a new database connection
	 * @return No Content
	 */
	addConnection(body: AddMongoConnectionRequest, cancelToken?: CancelToken | undefined): Promise<void> {
		let url_ = this.baseUrl + "/api/database/connections";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(body);

		let options_: AxiosRequestConfig = {
			data: content_,
			method: "POST",
			url: url_,
			headers: {
				"Content-Type": "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processAddConnection(_response);
			});
	}

	/**
	 * Replace the connectionString for a connection
	 * @param idConnection Connection's id
	 * @param body new connectionString
	 * @return No Content
	 */
	updateConnectionString(idConnection: string, body: string, cancelToken?: CancelToken | undefined): Promise<void> {
		let url_ = this.baseUrl + "/api/database/connections/{idConnection}/connection-string";
		if (idConnection === undefined || idConnection === null) throw new Error("The parameter 'idConnection' must be defined.");
		url_ = url_.replace("{idConnection}", encodeURIComponent("" + idConnection));
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(body);

		let options_: AxiosRequestConfig = {
			data: content_,
			method: "PUT",
			url: url_,
			headers: {
				"Content-Type": "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processUpdateConnectionString(_response);
			});
	}

	/**
	 * Replace the connectionString for a connection
	 * @param idConnection Connection's id
	 * @return No Content
	 */
	deleteConnection(idConnection: string, cancelToken?: CancelToken | undefined): Promise<void> {
		let url_ = this.baseUrl + "/api/database/connections/{idConnection}";
		if (idConnection === undefined || idConnection === null) throw new Error("The parameter 'idConnection' must be defined.");
		url_ = url_.replace("{idConnection}", encodeURIComponent("" + idConnection));
		url_ = url_.replace(/[?&]$/, "");

		let options_: AxiosRequestConfig = {
			method: "DELETE",
			url: url_,
			headers: {},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processDeleteConnection(_response);
			});
	}

	protected processGetInfos(response: AxiosResponse): Promise<GetConnectionInformationResponse> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 200) {
			const _responseText = response.data;
			let result200: any = null;
			let resultData200 = _responseText;
			result200 = JSON.parse(resultData200);
			return Promise.resolve<GetConnectionInformationResponse>(result200);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<GetConnectionInformationResponse>(null as any);
	}

	protected processGetConnections(response: AxiosResponse): Promise<MongoConnectionData[]> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 200) {
			const _responseText = response.data;
			let result200: any = null;
			let resultData200 = _responseText;
			result200 = JSON.parse(resultData200);
			return Promise.resolve<MongoConnectionData[]>(result200);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<MongoConnectionData[]>(null as any);
	}

	protected processAddConnection(response: AxiosResponse): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 204) {
			const _responseText = response.data;
			return Promise.resolve<void>(null as any);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<void>(null as any);
	}

	protected processUpdateConnectionString(response: AxiosResponse): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 204) {
			const _responseText = response.data;
			return Promise.resolve<void>(null as any);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<void>(null as any);
	}

	protected processDeleteConnection(response: AxiosResponse): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 204) {
			const _responseText = response.data;
			return Promise.resolve<void>(null as any);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<void>(null as any);
	}
}

/** Represents a request to add a new MongoDB connection. */
export interface AddMongoConnectionRequest {
	/** The name for the new MongoDB connection. */
	name: string;
	/** The connection string for the new MongoDB connection. */
	connectionString: string;
}

/** The BaseBackupTask class is an abstract class to be inherited by any backup task. */
export interface BaseBackupTask {
	/** Gets or sets a name for the BaseBackupTask object. This property is required. */
	name: string;
}

export interface CollectionInfo {
	/** Collection's name */
	name: string;
	/** Collection documents count */
	documents: number;
	/** Collection size info */
	sizes: CollectionSizes;
}

/** Collection size in MegaBytes */
export interface CollectionSizes {
	/** Sum of BackupMaker.Api.Abstractions.Models.Base.Database.Mongo.Info.CollectionSizes.DocumentsSize and BackupMaker.Api.Abstractions.Models.Base.Database.Mongo.Info.CollectionSizes.IndexesSize */
	totalSize: number;
	documentsSize: number;
	indexesSize: {
		[key: string]: number;
	};
}

/** JobBase is an abstract class that represents a foundational job structure for various types of jobs. */
export interface JobBase {
	/** Property Name represents the name of the job. */
	name: string;
	/** Represents the scheduling interval for the job.
The scheduling interval follows the cron syntax. */
	cronInterval: string;
	/** Represents the deployment type of this job, defined by the Enum JobDeploy. */
	deployType: JobDeploy;
	/** Represents the backup type of this job, defined by the Enum JobBackup. */
	backupType: JobBackup;
}

/** Represents a request to create a new job. */
export interface CreateJobRequest extends JobBase {
	/** Gets or sets the unique identifier (ID) for the deployment associated with this job. */
	idDeploy: string;
	/** Gets or sets the unique identifier (ID) for the backup associated with this job. */
	idBackup: string;
}

export interface DatabaseInfo {
	/** Database's name */
	name: string;
	/** Database's Collections */
	collections: CollectionInfo[];
}

/** The DeployBase class serves as a data container for deployment information. */
export interface DeployBase {
	/** Gets or sets the name of the DeployBase object. */
	name: string;
}

/** FTP server connection details. */
export interface FtpConnection {
	/** FTP server host. */
	host: string;
	/** Username for FTP server. */
	username: string;
	/** Password for the provided username. */
	password: string;
	/** FTP server port. */
	port: number;
	/** Encryption method for FTP connection. */
	encryption: FtpEncryption;
}

/** FTP deployment details. */
export interface FtpDeployBase extends DeployBase {
	/** FTP deployment connection details. */
	connection: FtpConnection;
	/** The file system path where deployment files are outputted. */
	outputPath: string;
}

/** Data model for ftp deployment-related operations. */
export interface FtpDeployData extends FtpDeployBase {
	/** The unique identifier (ID) for the ftp deployment. */
	id: string;
}

export interface FtpDeployEntity extends FtpDeployBase {
	id: ObjectId;
}

/** Types of FTP encryption methods. */
export enum FtpEncryption {
	None = "None",
	Implicit = "Implicit",
	Explicit = "Explicit",
}

/** Represents the response containing the information about the connections. */
export interface GetConnectionInformationResponse {
	/** The key is the connection's unique identifier, and the value is a list of database information. */
	data: {
		[key: string]: DatabaseInfo[];
	};
	/** The key is the operation's unique identifier, and the value is the error message. */
	errors: {
		[key: string]: string;
	};
}

/** Represents the type of backups that this job can handle. */
export enum JobBackup {
	Mongo = "Mongo",
}

/** Represents a data model used for job-related operations. */
export interface JobData extends CreateJobRequest {
	/** Gets or sets the unique identifier (ID) of the job. */
	id: string;
}

/** Represents the types of deployment this job supports. */
export enum JobDeploy {
	Local = "Local",
	Ftp = "Ftp",
}

/** The JobEntity class inherits from JobBase and serves as a data container for job information. */
export interface JobEntity extends JobBase {
	/** Gets or sets the Id of the related JobDeploy object. */
	idDeploy: ObjectId;
	/** Gets or sets the Id of the related JobBackup object. */
	idBackup: ObjectId;
	/** Gets or sets the unique identifier for the JobEntity object. */
	id: ObjectId;
}

/** Serves as a data container for local deployment information. */
export interface LocalDeployBase extends DeployBase {
	/** The file system path where deployment files are outputted. */
	outputPath: string;
}

/** Represents a data model for local deployment-related operations. */
export interface LocalDeployData extends LocalDeployBase {
	/** Gets or sets the unique identifier (ID) for the local deployment. */
	id: string;
}

/** The class represents a local deployment entity. */
export interface LocalDeployEntity extends LocalDeployBase {
	/** Gets or sets the ObjectId of the local deployment entity. This field is also the BsonId. */
	id: ObjectId;
}

/** JobBackup job for a mongo connection */
export interface MongoBackupTaskBase extends BaseBackupTask {
	/** Id of the mongo connection */
	idConnection: string;
	/** Mapping of a database to a list of collection to backup */
	elements: {
		[key: string]: string[];
	};
}

/** Represents a data model used for MongoDB backup task-related operations. */
export interface MongoBackupTaskData extends MongoBackupTaskBase {
	/** Gets or sets the unique identifier (ID) of the job detail associated with this MongoBackupTaskBase. */
	id: string;
}

/** This class represents the entities of the MongoDB backup tasks. */
export interface MongoBackupTaskEntity extends MongoBackupTaskBase {
	/** Gets or sets the ID of the MongoDB backup task entity. */
	id: ObjectId;
}

/** The MongoConnectionBase class is used to establish connections to MongoDB. */
export interface MongoConnectionBase {
	/** Gets or sets the name for the MongoConnectionBase object. This property is required. */
	name: string;
	/** Gets or sets the Connection String for the MongoDB connection entity. */
	connectionString: string;
}

/** Represents a data model used for MongoDB connection operations. */
export interface MongoConnectionData extends MongoConnectionBase {
	/** Gets or sets the unique identifier (ID) for this MongoDB connection. */
	id: string;
}

/** This class represents the entities of the MongoDB connections. */
export interface MongoConnectionEntity extends MongoConnectionBase {
	/** Gets or sets the ID of the MongoDB connection entity. */
	id: ObjectId;
}

export interface ObjectId {
	readonly timestamp?: number;
	readonly machine?: number;
	readonly pid?: number;
	readonly increment?: number;
	readonly creationTime?: string;
}

export class ApiException extends Error {
	override message: string;
	status: number;
	response: string;
	headers: {
		[key: string]: any;
	};
	result: any;
	protected isApiException = true;

	constructor(
		message: string,
		status: number,
		response: string,
		headers: {
			[key: string]: any;
		},
		result: any
	) {
		super();

		this.message = message;
		this.status = status;
		this.response = response;
		this.headers = headers;
		this.result = result;
	}

	static isApiException(obj: any): obj is ApiException {
		return obj.isApiException === true;
	}
}

function throwException(
	message: string,
	status: number,
	response: string,
	headers: {
		[key: string]: any;
	},
	result?: any
): any {
	if (result !== null && result !== undefined) throw result;
	else throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
	return obj && obj.isAxiosError === true;
}
